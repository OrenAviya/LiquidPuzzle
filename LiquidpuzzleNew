import heapq

class Node:
    def __init__(self, state, parent=None, cost=0, heuristic=0):
        self.state = state
        self.parent = parent
        self.cost = cost
        self.heuristic = heuristic

    def f(self):
        return self.cost + self.heuristic

def astar(start_state, goal_state, heuristic, successors):
    open_list = []
    closed_set = set()

    start_node = Node(start_state, None, 0, heuristic(start_state, goal_state))
    heapq.heappush(open_list, (start_node.f(), id(start_node), start_node))

    while open_list:
        _, _, current_node = heapq.heappop(open_list)

        if current_node.state == goal_state:
            path = []
            while current_node:
                path.append(current_node.state)
                current_node = current_node.parent
            return path[::-1]

        state_tuple = tuple(map(tuple, current_node.state))
        closed_set.add(state_tuple)

        for successor_state, cost in successors(current_node.state, goal_state):
            successor_tuple = tuple(map(tuple, successor_state))
            if successor_tuple in closed_set:
                continue

            g = current_node.cost + cost
            h = heuristic(successor_state, goal_state)
            f = g + h

            dominates = False
            for _, _, existing_node in open_list:
                if existing_node.state == successor_state and existing_node.cost <= g:
                    dominates = True
                    break

            if not dominates:
                successor_node = Node(successor_state, current_node, g, h)
                heapq.heappush(open_list, (successor_node.f(), id(successor_node), successor_node))

    return None

def heuristic(current_state, goal_state):
    total_blocks = 0

    for i, tank in enumerate(current_state):
        for j, fluid in enumerate(tank):
            try:
                goal_position = next((gi, gj) for gi, goal_tank in enumerate(goal_state) for gj, goal_fluid in enumerate(goal_tank) if goal_fluid == fluid)
                if i == goal_position[0] and j == goal_position[1]:
                    continue

                if len(goal_state[goal_position[0]]) < len(current_state[0]):
                    for goal_tank_index in range(goal_position[0] + 1, len(goal_state)):
                        if goal_state[goal_tank_index][goal_position[1]] != fluid:
                            total_blocks += 1
            except StopIteration:
                pass

    return total_blocks

def successors(current_state, goal_state):
    successors = []

    for from_tank in range(len(current_state)):
        for to_tank in range(len(current_state)):
            if from_tank != to_tank:
                if can_move_liquid(current_state, from_tank, to_tank):
                    new_state = [list(tank) for tank in current_state]
                    new_state[to_tank].insert(0, new_state[from_tank].pop(0))
                    successors.append((new_state, 1))

    return successors

def can_move_liquid(current_state, from_tank, to_tank):
    if from_tank >= len(current_state) or from_tank < 0:
        return False
    if not current_state[from_tank]:
        return False
    if to_tank >= len(current_state) or to_tank < 0:
        return False
    if is_full(current_state, to_tank):
        return False

    from_top_color = current_state[from_tank][0]
    to_top_color = current_state[to_tank][0] if current_state[to_tank] else None

    return from_top_color == to_top_color or is_empty(current_state, to_tank)

def is_full(current_state, tank):
    return len(current_state[tank]) >= len(current_state[0])

def is_empty(current_state, tank):
    return len(current_state[tank]) == 0

# Example usage
start_state = [
    [1, 3, 5, 4, 4, 7, 6, 1], [2, 2, 0, 0, 4, 3, 6, 7],
    [2, 1, 1, 4, 5, 6, 0, 2], [0, 6, 6, 5, 4, 7, 7, 3],
    [3, 4, 1, 0, 5, 7, 4, 4], [7, 6, 2, 2, 3, 1, 0, 0],
    [7, 3, 3, 1, 2, 5, 5, 6], [7, 6, 5, 5, 3, 2, 1, 0], [], []
]

goal_state = [
    [1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2],
    [3, 3, 3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4, 4, 4],
    [5, 5, 5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6, 6, 6],
    [7, 7, 7, 7, 7, 7, 7, 7], [8, 8, 8, 8, 8, 8, 8, 8], [], []
]



path = astar(start_state, goal_state, heuristic, successors)

if path:
    print("Path found!")
    for state in path:
        print(state)
else:
    print("No path found.")