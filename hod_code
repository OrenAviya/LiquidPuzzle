import heapq
import time
import random

class GameVariables:
    def __init__(self):
        # Uncomment one of the configurations to test different examples
        # Example 1
        # self.empty_tanks = 2
        # self.full_tanks = 8
        # self.size = 8
        # self.num_colors = 8
        # self.initial_state = [
        #     [1, 3, 5, 4, 4, 7, 6, 1], [2, 2, 0, 0, 4, 3, 6, 7],
        #     [2, 1, 1, 4, 5, 6, 0, 2], [0, 6, 6, 5, 4, 7, 7, 3],
        #     [3, 4, 1, 0, 5, 7, 4, 4], [7, 6, 2, 2, 3, 1, 0, 0],
        #     [7, 3, 3, 1, 2, 5, 5, 6], [7, 6, 5, 5, 3, 2, 1, 0], [], []
        # ]



    # # Example 2
    #     self.empty_tanks = 1
    #     self.full_tanks = 1
    #     self.size = 4
    #     self.num_colors = 4
    #     self.initial_state = [[], [0, 2, 0, 2], [3, 3, 2, 0], [3, 0, 1, 3], [2, 1, 1, 1]]



    # Example 9
        # self.empty_tanks = 2
        # self.full_tanks = 8
        # self.size = 8
        # self.num_colors = 8
        # self.initial_state = [[], [], [1, 4, 1, 6, 2, 1, 5, 5], [2, 2, 6, 4, 5, 4, 7, 3], [3, 3, 2, 3, 0, 3, 7, 0], [4, 1, 2, 6, 2, 5, 7, 0], [5, 7, 0, 4, 0, 7, 5, 2], [6, 1, 5, 4, 6, 3, 1, 0], [7, 6, 2, 7, 6, 0, 4, 1], [1, 5, 6, 4, 3, 3, 0, 7]]


        # Example 13
        self.empty_tanks = 5
        self.full_tanks = 20
        self.size = 20
        self.num_colors = 20
        self.initial_state = [[], [], [], [], [], 
                              [4, 4, 4, 2, 6, 18, 9, 3, 18, 1, 5, 0, 6, 13, 18, 9, 14, 13, 2, 3],
                              [5, 5, 5, 5, 5, 6, 4, 17, 16, 9, 5, 5, 6, 17, 14, 12, 16, 3, 11, 0],
                              [14, 16, 10, 0, 6, 19, 12, 10, 1, 7, 14, 14, 2, 4, 6, 4, 3, 3, 1, 1],
                              [7, 7, 7, 7, 7, 7, 11, 13, 19, 2, 18, 17, 3, 2, 1, 16, 0, 1, 5, 4],
                              [8, 8, 8, 8, 8, 8, 8, 8, 7, 1, 11, 19, 9, 14, 9, 17, 1, 1, 1, 14],
                              [16, 8, 12, 15, 13, 2, 2, 8, 7, 2, 15, 19, 1, 6, 2, 2, 4, 6, 1, 12],
                              [10, 10, 10, 10, 10, 10, 10, 10, 12, 3, 15, 19, 4, 1, 16, 14, 11, 16, 18, 0],
                              [5, 13, 10, 11, 9, 12, 5, 10, 0, 3, 8, 3, 3, 10, 3, 17, 18, 14, 17, 15],
                              [12, 12, 12, 6, 19, 19, 2, 4, 4, 13, 2, 3, 10, 15, 0, 4, 17, 9, 15, 16],
                              [13, 13, 13, 13, 13, 13, 13, 4, 11, 19, 6, 11, 9, 16, 11, 7, 0, 0, 17, 1],
                              [14, 14, 14, 14, 14, 14, 14, 7, 18, 7, 17, 19, 17, 19, 11, 13, 7, 8, 0, 19],
                              [15, 15, 3, 0, 4, 8, 2, 18, 12, 11, 19, 0, 0, 7, 10, 15, 18, 17, 5, 0],
                              [16, 16, 16, 14, 10, 5, 8, 2, 15, 3, 12, 18, 4, 18, 11, 6, 5, 6, 15, 17],
                              [13, 1, 3, 10, 16, 8, 9, 17, 7, 8, 5, 11, 9, 9, 15, 12, 5, 7, 19, 0],
                              [18, 18, 18, 17, 12, 3, 11, 6, 2, 19, 18, 1, 15, 9, 14, 12, 4, 15, 5, 7],
                              [17, 10, 19, 18, 2, 12, 6, 17, 19, 2, 13, 8, 9, 5, 4, 11, 12, 18, 13, 11],
                              [3, 9, 16, 16, 12, 3, 6, 16, 8, 17, 11, 1, 18, 0, 0, 17, 7, 18, 19, 15],
                              [10, 14, 6, 8, 12, 13, 11, 7, 3, 9, 10, 15, 15, 0, 15, 19, 12, 9, 4, 4],
                              [5, 16, 2, 18, 1, 17, 6, 14, 16, 16, 6, 6, 0, 16, 4, 9, 15, 17, 0, 13],
                              [3, 19, 7, 11, 13, 15, 11, 1, 9, 2, 2, 6, 9, 11, 8, 5, 12, 19, 9, 1]]


class Node:
    def __init__(self, state, parent=None, g=0, h=0):
        self.state = state
        self.parent = parent
        self.g = g
        self.h = h

    def f(self):
        return self.g + self.h

def list_to_tuple(lst):
    if isinstance(lst, list):
        return tuple(list_to_tuple(item) for item in lst)
    else:
        return lst

def astar(start_state, goal_state, heuristic, successors):
    open_list = []
    closed_set = set()
    
    start_node = Node(start_state, None, 0, heuristic(start_state, goal_state))
    heapq.heappush(open_list, (start_node.f(), id(start_node), start_node))
    
    iteration = 0
    while open_list:
        iteration += 1
        if iteration % 1000 == 0:
            print(f"Iteration: {iteration}, Open list size: {len(open_list)}, Closed set size: {len(closed_set)}")
        
        _, _, current_node = heapq.heappop(open_list)
        
        if current_node.state == goal_state:
            print("Goal reached!")
            path = []
            while current_node:
                path.append(current_node.state)
                current_node = current_node.parent
            path = path[::-1]
            print(f"Optimal solution found in {len(path) - 1} steps")
            return path

        if list_to_tuple(current_node.state) in closed_set:
            continue

        closed_set.add(list_to_tuple(current_node.state))

        for successor_state in successors(current_node.state):
            g = current_node.g + 1
            h = heuristic(successor_state, goal_state)
            new_node = Node(successor_state, current_node, g, h)
            heapq.heappush(open_list, (new_node.f(), id(new_node), new_node))

    print("Goal could not be reached.")
    return None

def manhattan_distance(state, goal_state):
    distance = 0
    for i in range(len(state)):
        for j in range(len(state[i])):
            if i < len(goal_state) and j < len(goal_state[i]):
                value = state[i][j]
                if value != goal_state[i][j]:
                    goal_position = find_position(goal_state, value)
                    distance += abs(i - goal_position[0]) + abs(j - goal_position[1])
    # Introduce a small random component to the heuristic value
    random_component = random.uniform(0, 1) * 0.1  # Adjust the scale factor as needed
    return distance + random_component

def find_position(state, value):
    for i in range(len(state)):
        for j in range(len(state[i])):
            if state[i][j] == value:
                return i, j

def successors(state):
    successor_states = []
    for i in range(len(state)):
        if state[i]:
            for j in range(len(state)):
                if i != j:
                    if not state[j] or state[j][-1] == state[i][-1]:
                        new_state = [list(row) for row in state]
                        new_state[j].append(new_state[i].pop())
                        successor_states.append(new_state)
    return successor_states

if __name__ == "_main_":
    game = GameVariables()
    start_time = time.time()
    path = astar(game.initial_state, [[] for _ in range(game.empty_tanks)], manhattan_distance, successors)
    end_time = time.time()
    print("Execution time:", end_time - start_time)